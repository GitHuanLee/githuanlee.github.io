<!-- build time:Sat Feb 20 2021 19:17:34 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Lee" href="http://blog.huanlee.cn/rss.xml"><link rel="alternate" type="application/atom+xml" title="Lee" href="http://blog.huanlee.cn/atom.xml"><link rel="alternate" type="application/json" title="Lee" href="http://blog.huanlee.cn/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.1.6"><meta name="description" content="见习码农"><link rel="canonical" href="http://blog.huanlee.cn/computer-science/java/SpringBoot%E4%BA%8B%E7%89%A9%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"><title>SpringBoot事物传播机制 - Java - 计算机科学 | Lee = Lee = 生活笔记</title><meta name="generator" content="Hexo 5.1.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">SpringBoot事物传播机制</h1><div class="meta"><span class="item" title="创建时间：2021-02-20 17:24:40"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-02-20T17:24:40+08:00">2021-02-20</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>15k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Lee</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciub8ja1j20zk0m81ky.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4fomxoj20zk0m8axp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicm07ih54j20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main id="main"><div class="inner"><div id="content" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span> <i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.huanlee.cn/computer-science/java/SpringBoot%E4%BA%8B%E7%89%A9%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Lee"><meta itemprop="description" content="生活笔记, 见习码农"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Lee"></span><div class="body md" itemprop="articleBody"><div class="note info"><p>在实际项目中，调用外部接口时，提供了一个记录日志的功能，但是无论外部接口是否调用成功，调用失败会抛出异常，都想记录下调用日志和返回结果，而延伸出的一些列思考。</p></div><h1 id="spring-boot-transaction"><a class="anchor" href="#spring-boot-transaction">#</a> Spring Boot Transaction</h1><h2 id="事物管理方式"><a class="anchor" href="#事物管理方式">#</a> 事物管理方式</h2><p>在 Spring 中，事务有两种实现方式，分别是编程式事务管理和声明式事务管理两种方式。</p><ul><li>编程式事务管理： 编程式事务管理使用 TransactionTemplate 或者直接使用底层的 PlatformTransactionManager。对于编程式事务管理，spring 推荐使用 TransactionTemplate。</li><li>声明式事务管理： 建立在 AOP 之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。<br>声明式事务管理不需要入侵代码，通过 @Transactional 就可以进行事务操作，更快捷而且简单，推荐使用。</li></ul><h2 id="事务提交方式"><a class="anchor" href="#事务提交方式">#</a> 事务提交方式</h2><p>默认情况下，数据库处于自动提交模式。每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果执行失败则隐式的回滚事务。<br>对于正常的事务管理，是一组相关的操作处于一个事务之中，因此必须关闭数据库的自动提交模式。不过，这个我们不用担心，spring 会将底层连接的自动提交特性设置为 false。也就是在使用 spring 进行事物管理的时候，spring 会将是否自动提交设置为 false，等价于 JDBC 中的 <code>connection.setAutoCommit(false);</code> ，在执行完之后在进行提交， <code>connection.commit();</code> 。</p><h2 id="事务隔离级别"><a class="anchor" href="#事务隔离级别">#</a> 事务隔离级别</h2><p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是 TransactionDefinition.ISOLATION_READ_COMMITTED。</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如 PostgreSQL 实际上并没有此级别。</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h2 id="事务回滚规则"><a class="anchor" href="#事务回滚规则">#</a> 事务回滚规则</h2><p>指示 spring 事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring 事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。<br>默认配置下，spring 只有在抛出的异常为运行时 unchecked 异常时才回滚该事务，也就是抛出的异常为 RuntimeException 的子类 (Errors 也会导致事务回滚)，而抛出 checked 异常则不会导致事务回滚。<br>可以明确的配置在抛出那些异常时回滚事务，包括 checked 异常。也可以明确定义那些异常抛出时不回滚事务。</p><h2 id="事务常用配置"><a class="anchor" href="#事务常用配置">#</a> 事务常用配置</h2><ul><li>readOnly：该属性用于设置当前事务是否为只读事务，设置为 true 表示只读，false 则表示可读写，默认值为 false。例如：@Transactional (readOnly=true)；</li><li>rollbackFor： 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：指定单一异常类：@Transactional (rollbackFor=RuntimeException.class) 指定多个异常类：@Transactional (rollbackFor={RuntimeException.class, Exception.class})；</li><li>rollbackForClassName： 该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：指定单一异常类名称 @Transactional (rollbackForClassName=”RuntimeException”) 指定多个异常类名称：@Transactional (rollbackForClassName={“RuntimeException”,”Exception”})。</li><li>noRollbackFor：该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如：指定单一异常类：@Transactional (noRollbackFor=RuntimeException.class) 指定多个异常类：@Transactional (noRollbackFor={RuntimeException.class, Exception.class})。</li><li>noRollbackForClassName：该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如：指定单一异常类名称：@Transactional (noRollbackForClassName=”RuntimeException”) 指定多个异常类名称：@Transactional (noRollbackForClassName={“RuntimeException”,”Exception”})。</li><li>propagation ： 该属性用于设置事务的传播行为。例如：@Transactional (propagation=Propagation.NOT_SUPPORTED,readOnly=true)。</li><li>isolation：该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置。</li><li>timeout：该属性用于设置事务的超时秒数，默认值为 - 1 表示永不超时。</li></ul><h2 id="事物注意事项"><a class="anchor" href="#事物注意事项">#</a> 事物注意事项</h2><ol><li>要根据实际的需求来决定是否要使用事物，最好是在编码之前就考虑好，不然到以后就难以维护；</li><li>如果使用了事物，请务必进行事物测试，因为很多情况下以为事物是生效的，但是实际上可能未生效！</li><li>事物 @Transactional 的使用要放再类的公共 (public) 方法中，需要注意的是在 protected、private 方法上使用 @Transactional 注解，它也不会报错 (IDEA 会有提示)，但事务无效。</li><li>事物 @Transactional 是不会对该方法里面的子方法生效！也就是你在公共方法 A 声明的事物 @Transactional，但是在 A 方法中有个子方法 B 和 C，其中方法 B 进行了数据操作，但是该异常被 B 自己处理了，这样的话事物是不会生效的！反之 B 方法声明的事物 @Transactional，但是公共方法 A 却未声明事物的话，也是不会生效的！如果想事物生效，需要将子方法的事务控制交给调用的方法，在子方法中使用 rollbackFor 注解指定需要回滚的异常或者将异常抛出交给调用的方法处理。一句话就是在使用事物的异常由调用者进行处理！</li><li>事物 @Transactional 由 spring 控制的时候，它会在抛出异常的时候进行回滚。如果自己使用 catch 捕获了处理了，是不生效的，如果想生效可以进行手动回滚或者在 catch 里面将异常抛出，比如 <code>throw new RuntimeException();</code> 。</li></ol><h1 id="事务传播行为"><a class="anchor" href="#事务传播行为">#</a> 事务传播行为</h1><h2 id="required"><a class="anchor" href="#required">#</a> REQUIRED</h2><p>也是默认的传递属性，其特点在于：</p><ul><li>如果存在一个事务，则在当前事务中运行，</li><li>如果没有事务则开启一个新的事务。</li></ul><p>使用方式也比较简单，不设置 @Transactional 注解的 propagation 属性，或者设置为 REQUIRED 即可</p><pre><code class="language-java">/**
 * 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务
 *
 * @param id
 */
@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)
public void required(int id) throws Exception &#123;
    if (this.updateName(id)) &#123;
        this.query(&quot;required: after updateMoney name&quot;, id);
        if (this.updateMoney(id)) &#123;
            return;
        &#125;
    &#125;

    throw new Exception(&quot;事务回滚!!!&quot;);
&#125;
</code></pre><p>上面就是一个基础的使用姿势</p><pre><code class="language-java">private void testRequired() &#123;
    int id = 420;
    call(&quot;Required事务运行&quot;, id, propagationDemo::required);
&#125;
</code></pre><p>输出结果如下</p><pre><code class="language-log">============ Required事务运行 start ========== 
Required事务运行 &gt;&gt;&gt;&gt; &#123;id=420, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
required: after updateMoney name &gt;&gt;&gt;&gt; &#123;id=420, name=更新, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
事务回滚!!!
Required事务运行 &gt;&gt;&gt;&gt; &#123;id=420, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
============ Required事务运行 end ========== 
</code></pre><h2 id="supports"><a class="anchor" href="#supports">#</a> SUPPORTS</h2><p>其特点是在事务里面，就事务执行；否则就非事务执行，即</p><ul><li>如果存在一个事务，支持当前事务</li><li>如果没有事务，则非事务的执行</li></ul><p>使用姿势和前面基本一致</p><pre><code class="language-java">@Transactional(propagation = Propagation.SUPPORTS, rollbackFor = Exception.class)
public void support(int id) throws Exception &#123;
    if (this.updateName(id)) &#123;
        this.query(&quot;support: after updateMoney name&quot;, id);
        if (this.updateMoney(id)) &#123;
            return;
        &#125;
    &#125;

    throw new Exception(&quot;事务回滚!!!&quot;);
&#125;
</code></pre><p>这个传递属性比较特别，所以我们的测试 case 需要两个，一个事务调用，一个非事务调用</p><p>测试事务调用时，我们新建一个 bean: PropagationDemo2，下面的 support 方法支持事务运行</p><pre><code class="language-java">@Component
public class PropagationDemo2 &#123;
    @Autowired
    private PropagationDemo propagationDemo;

    @Transactional(rollbackFor = Exception.class)
    public void support(int id) throws Exception &#123;
        // 事务运行
        propagationDemo.support(id);
    &#125;
&#125;
</code></pre><p>对于非事务调用，则是直接在测试类中调用 (请注意下面的 call 方法，调用的是两个不同 bean 中的 support 方法)</p><pre><code class="language-java">private void testSupport() &#123;
    int id = 430;
    // 非事务方式，异常不会回滚
    call(&quot;support无事务运行&quot;, id, propagationDemo::support);

    // 事务运行
    id = 440;
    call(&quot;support事务运行&quot;, id, propagationDemo2::support);
&#125;
</code></pre><p>输出结果如下：</p><pre><code class="language-log">============ support无事务运行 start ========== 
support无事务运行 &gt;&gt;&gt;&gt; &#123;id=430, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
support: after updateMoney name &gt;&gt;&gt;&gt; &#123;id=430, name=更新, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
事务回滚!!!
support无事务运行 &gt;&gt;&gt;&gt; &#123;id=430, name=更新, money=210, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
============ support无事务运行 end ========== 

============ support事务运行 start ========== 
support事务运行 &gt;&gt;&gt;&gt; &#123;id=440, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
support: after updateMoney name &gt;&gt;&gt;&gt; &#123;id=440, name=更新, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
事务回滚!!!
support事务运行 &gt;&gt;&gt;&gt; &#123;id=440, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
============ support事务运行 end ========== 
</code></pre><p>从上面的输出，也可以得出结果：非事务执行时，不会回滚；事务执行时，回滚</p><h2 id="mandatory"><a class="anchor" href="#mandatory">#</a> MANDATORY</h2><p>需要在一个正常的事务内执行，否则抛异常</p><p>使用姿势如下</p><pre><code class="language-java">@Transactional(propagation = Propagation.MANDATORY, rollbackFor = Exception.class)
public void mandatory(int id) throws Exception &#123;
    if (this.updateName(id)) &#123;
        this.query(&quot;mandatory: after updateMoney name&quot;, id);
        if (this.updateMoney(id)) &#123;
            return;
        &#125;
    &#125;

    throw new Exception(&quot;事务回滚!!!&quot;);
&#125;
</code></pre><p>这种传播属性的特点是这个方法必须在一个已有的事务中运行，所以我们的测试 case 也比较简单，不再事务中运行时会怎样？</p><pre><code class="language-java">private void testMandatory() &#123;
    int id = 450;
    // 非事务方式，抛异常，这个必须在一个事务内部执行
    call(&quot;mandatory非事务运行&quot;, id, propagationDemo::mandatory);
&#125;
</code></pre><p>输出结果</p><pre><code class="language-log">============ mandatory非事务运行 start ========== 
mandatory非事务运行 &gt;&gt;&gt;&gt; &#123;id=450, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
No existing transaction found for transaction marked with propagation 'mandatory'
mandatory非事务运行 &gt;&gt;&gt;&gt; &#123;id=450, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
============ mandatory非事务运行 end ========== 
</code></pre><p>从上面的输出可知，直接抛出了异常，并不会执行方法内的逻辑</p><h2 id="not_support"><a class="anchor" href="#not_support">#</a> NOT_SUPPORT</h2><p>这个比较有意思，被它标记的方法，总是非事务地执行，如果存在活动事务，则挂起</p><p>（实在是没有想到，有什么场景需要这种传播属性）</p><p>一个简单的使用 case 如下：</p><pre><code class="language-java">@Transactional(propagation = Propagation.NOT_SUPPORTED, rollbackFor = Exception.class)
public void notSupport(int id) throws Exception &#123;
    if (this.updateName(id)) &#123;
        this.query(&quot;notSupport: after updateMoney name&quot;, id);
        if (this.updateMoney(id)) &#123;
            return;
        &#125;
    &#125;
    throw new Exception(&quot;回滚!&quot;);
&#125;
</code></pre><p>接下来需要好好的想一下我们的测试用例，首先是它需要在一个事务中调用，外部事物失败回滚，并不会影响上面这个方法的执行结果</p><p>我们在 PropagationDemo2 中，添加测试 case 如下</p><pre><code class="language-java">@Transactional(rollbackFor = Exception.class)
public void notSupport(int id) throws Exception &#123;
    // 挂起当前事务，以非事务方式运行
    try &#123;
        propagationDemo.notSupport(id);
    &#125; catch (Exception e) &#123;
    &#125;

    propagationDemo.query(&quot;notSupportCall: &quot;, id);
    propagationDemo.updateName(id, &quot;外部更新&quot;);
    propagationDemo.query(&quot;notSupportCall: &quot;, id);
    throw new Exception(&quot;回滚&quot;);
&#125;
</code></pre><p>输出结果如下</p><pre><code class="language-log">============ notSupport start ========== 
notSupport &gt;&gt;&gt;&gt; &#123;id=460, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
notSupport: after updateMoney name &gt;&gt;&gt;&gt; &#123;id=460, name=更新, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
notSupportCall:  &gt;&gt;&gt;&gt; &#123;id=460, name=更新, money=210, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
notSupportCall:  &gt;&gt;&gt;&gt; &#123;id=460, name=外部更新, money=210, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
回滚
notSupport &gt;&gt;&gt;&gt; &#123;id=460, name=更新, money=210, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
============ notSupport end ========== 

</code></pre><p>从上面输出可以看出</p><p>NOT_SUPPORT 标记的方法，属于非事务运行（因为抛异常，修改没有回滚）<br>外部事务回滚，不会影响其修改</p><h2 id="never"><a class="anchor" href="#never">#</a> NEVER</h2><p>总是非事务地执行，如果存在一个活动事务，则抛出异常。</p><p>使用姿势如下</p><pre><code class="language-java">/**
 * 总是非事务地执行，如果存在一个活动事务，则抛出异常。
 *
 * @param id
 * @throws Exception
 */
@Transactional(propagation = Propagation.NEVER, rollbackFor = Exception.class)
public void never(int id) throws Exception &#123;
    if (this.updateName(id)) &#123;
        this.query(&quot;notSupport: after updateMoney name&quot;, id);
        if (this.updateMoney(id)) &#123;
            return;
        &#125;
    &#125;
&#125;

</code></pre><p>我们的测试就比较简单了，如果在事务中运行，是不是会抛异常</p><p>在 PropagationDemo2 中，添加一个事务调用方法</p><pre><code class="language-java">@Transactional(rollbackFor = Exception.class)
public void never(int id) throws Exception &#123;
    propagationDemo.never(id);
&#125;
</code></pre><p>测试代码</p><pre><code class="language-java">private void testNever() &#123;
    int id = 470;
    call(&quot;never非事务&quot;, id, propagationDemo2::never);
&#125;
</code></pre><p>输出结果</p><pre><code class="language-log">============ never非事务 start ========== 
never非事务 &gt;&gt;&gt;&gt; &#123;id=470, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
Existing transaction found for transaction marked with propagation 'never'
never非事务 &gt;&gt;&gt;&gt; &#123;id=470, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
============ never非事务 end ==========
</code></pre><p>直接抛出了异常，并没有执行方法内的业务逻辑</p><h2 id="nested"><a class="anchor" href="#nested">#</a> NESTED</h2><p>其主要特点如下</p><ul><li>如果不存在事务，则开启一个事务运行</li><li>如果存在事务，则运行一个嵌套事务；</li></ul><p>上面提出了一个嵌套事务的概念，什么是嵌套事务呢？</p><ul><li>一个简单的理解：外部事务回滚，内部事务也会被回滚；内部事务回滚，外部无问题，并不会回滚外部事务<br>接下来设计两个测试用例，一个是内部事务回滚；一个是外部事务回滚</li></ul><ol><li>case1 内部事务</li></ol><pre><code class="language-java">@Transactional(propagation = Propagation.NESTED, rollbackFor = Exception.class)
public void nested(int id) throws Exception &#123;
    if (this.updateName(id)) &#123;
        this.query(&quot;nested: after updateMoney name&quot;, id);
        if (this.updateMoney(id)) &#123;
            return;
        &#125;
    &#125;

    throw new Exception(&quot;事务回滚!!!&quot;);
&#125;
</code></pre><p>在 PropagationDemo2 这个 bean 中，添加一个外部事务，捕获上面方法的异常，因此外部执行正常</p><pre><code class="language-java">@Transactional(rollbackFor = Exception.class)
public void nested(int id) throws Exception &#123;
    propagationDemo.updateName(id, &quot;外部事务修改&quot;);
    propagationDemo.query(&quot;nestedCall: &quot;, id);
    try &#123;
        propagationDemo.nested(id);
    &#125; catch (Exception e) &#123;
    &#125;
&#125;
</code></pre><p>测试代码</p><pre><code class="language-java">private void testNested() &#123;
    int id = 480;
    call(&quot;nested事务&quot;, id, propagationDemo2::nested);
&#125;
</code></pre><p>输出结果如下</p><pre><code class="language-log">============ nested事务 start ========== 
nested事务 &gt;&gt;&gt;&gt; &#123;id=480, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
nestedCall:  &gt;&gt;&gt;&gt; &#123;id=480, name=外部事务修改, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
nested: after updateMoney name &gt;&gt;&gt;&gt; &#123;id=480, name=更新, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
nested事务 &gt;&gt;&gt;&gt; &#123;id=480, name=外部事务修改, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
============ nested事务 end ==========
</code></pre><p>仔细看一下上面的结果，外部事务修改的结果都被保存了，内部事务的修改被回滚了，没有影响最终的结果</p><ol start="2"><li>case2 外部事务回滚</li></ol><pre><code class="language-java">@Transactional(propagation = Propagation.NESTED, rollbackFor = Exception.class)
public void nested2(int id) throws Exception &#123;
    if (this.updateName(id)) &#123;
        this.query(&quot;nested: after updateMoney name&quot;, id);
        if (this.updateMoney(id)) &#123;
            return;
        &#125;
    &#125;
&#125;
</code></pre><p>在 PropagationDemo2 这个 bean 中，添加一个外部事务，内部事务正常，但是外部事务抛异常，主动回滚</p><pre><code class="language-java">@Transactional(rollbackFor = Exception.class)
public void nested2(int id) throws Exception &#123;
    // 嵌套事务，外部回滚，会同步回滚内部事务
    propagationDemo.updateName(id, &quot;外部事务修改&quot;);
    propagationDemo.query(&quot;nestedCall: &quot;, id);
    propagationDemo.nested2(id);
    throw new Exception(&quot;事务回滚&quot;);
&#125;
</code></pre><p>测试代码</p><pre><code class="language-java">private void testNested() &#123;
    int id = 490;
    call(&quot;nested事务2&quot;, id, propagationDemo2::nested2);
&#125;
</code></pre><p>事输出结果如下</p><pre><code class="language-log">============ nested事务2 start ========== 
nested事务2 &gt;&gt;&gt;&gt; &#123;id=490, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
nestedCall:  &gt;&gt;&gt;&gt; &#123;id=490, name=外部事务修改, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
nested: after updateMoney name &gt;&gt;&gt;&gt; &#123;id=490, name=更新, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:46.0&#125;
事务回滚
nested事务2 &gt;&gt;&gt;&gt; &#123;id=490, name=初始化, money=200, is_deleted=false, create_at=2020-02-02 15:23:26.0, update_at=2020-02-02 15:23:26.0&#125;
============ nested事务2 end ========== 
</code></pre><p>仔细看上面的输出，对别 case1，其特别在于全部回滚了，内部事务的修改也被回滚了</p><h2 id="requires_new"><a class="anchor" href="#requires_new">#</a> REQUIRES_NEW</h2><p>这个和上面的 NESTED 有点相似，但是又不一样</p><ul><li>当存在活动事务时，新创建一个事务执行</li><li>当不存在活动事务时，和 REQUIRES 效果一致，创建一个事务执行</li></ul><p>### 注意</p><p><code>REQUIRES_NEW</code> 和 <code>NESTED</code> 相比，两个事务之间没有关系，任何一个回滚，对另外一个无影响</p><p>测试 case 和前面差不多，不多做细说...</p><p>## 小结<br>前面介绍了 7 中传播属性，下面简单对比和小结一下</p><table><thead><tr><th>事务</th><th>特点</th></tr></thead><tbody><tr><td>REQUIRED</td><td>默认，如果存在事务，则支持当前事务；不存在，则开启一个新事务</td></tr><tr><td>SUPPORTS</td><td>如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</td></tr><tr><td>MANDATORY</td><td>需要在一个正常的事务内执行，否则抛异常</td></tr><tr><td>REQUIRES_NEW</td><td>不管存不存在事务，都开启一个新事务</td></tr><tr><td>NOT_SUPPORTED</td><td>不管存不存在，都以非事务方式执行，当存在事务时，挂起事务</td></tr><tr><td>NEVER</td><td>非事务方式执行，如果存在事务，则抛异常</td></tr><tr><td>NESTED</td><td>如果不存在事务，则开启一个事务运行；如果存在事务，则运行一个嵌套事务</td></tr></tbody></table><h1 id="事物方法之间的调用"><a class="anchor" href="#事物方法之间的调用">#</a> 事物方法之间的调用</h1><h2 id="同类方法调用"><a class="anchor" href="#同类方法调用">#</a> 同类方法调用</h2><p>示例：</p><pre><code class="language-java"> @Transactional(rollbackFor = Exception.class)
    public void save2(User user)&#123;
        this.save(user);
        throw new RuntimeException(&quot;异常&quot;);
    &#125;


    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void save(User user)&#123;
        userMapper.insert(user);
    &#125;
</code></pre><p>当调用 <code>save2()</code> 时，数据库中并不会保存数据。</p><h2 id="不同类方法调用"><a class="anchor" href="#不同类方法调用">#</a> 不同类方法调用</h2><pre><code class="language-java"> @Service
public class TestService &#123;

  @Autowired
  UserService userService;

  @Transactional(rollbackFor = Exception.class)
  public void test()&#123;
    User user = new User();
    user.setUserName(&quot;赵四&quot;);
    user.setPassWord(&quot;123456&quot;);
    user.setRealName(&quot;赵四&quot;);
    userService.save2(user);

    throw new RuntimeException(&quot;异常回滚&quot;);

  &#125;

&#125;

@Service
public class UserService &#123;
    @Autowired
    UserMapper userMapper;
    public User Sel(int id)&#123;
        return userMapper.Sel(id);
    &#125;
    @Transactional(rollbackFor = Exception.class)
    public void save2(User user)&#123;
        this.save(user);
    &#125;


    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void save(User user)&#123;
        userMapper.insert(user);
    &#125;
&#125;
</code></pre><p>当调用 <code>test()</code> 方法时，数据也不会保存到数据库中。</p><h2 id="结论总结"><a class="anchor" href="#结论总结">#</a> 结论总结</h2><ol><li><mark>同一个类的方法调用</mark>，外围方法和内围方法其中一个有事务注解或者两者都有注解，则注解给外部方法，内部方法则看成外部方法的一部分，只要外部方法感受不到异常 (内外方法都未抛异常、内部抛出但内部或外部捕获、外部抛出外部捕获) 都不会回滚，只要外部方法感受到异常 (内部或外部抛出，但未捕获)，内外方法都会回滚。同一个类的方法调用，如果两者都没有事务注解，则没有事务，此时，无论如何都不可能存在回滚的情况。</li><li><mark>不同类的方法调用</mark>，外部方法调用不同类的内部方法，外部方法有事务时，分为两种情况：1、内部方法无事务。此时之只要把内部方法看成外部方法的一部分就可以了。只要外部方法感受不到异常（内外都不抛异常、内抛内捕获、内抛外捕获、外抛外捕获），就不会回滚。只要感受到异常就会回滚（内抛或外抛，但均不捕获）。2、内部方法有事务，则内部方法共用同一事物，与内部方法没有事务的区别是，内部方法有事务只要内部方法感受到异常，就会回滚，并且导致外部方法也回滚，即使外部方法捕获了内部方法抛出的异常。</li><li><mark>当内部方法需要不同的传播机制时</mark>，无论是通过 <code>this.方法</code> 或者直接调用 <code>方法</code> 的方式，都不会触发内部方法的事务管理，可以通过以下两种解决方式解决：<ul><li>拆分成两个类，改为外部调用外部的形式。</li><li>通过 SpringBean 注入当前 Bean，通过 <code>Bean.方法</code> 的形式调用内部方法。</li></ul></li></ol></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-02-20 19:13:59" itemprop="dateModified" datetime="2021-02-20T19:13:59+08:00">2021-02-20</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Lee <i class="ic i-at"><em>@</em></i>Lee</li><li class="link"><strong>本文链接：</strong> <a href="http://blog.huanlee.cn/computer-science/java/SpringBoot%E4%BA%8B%E7%89%A9%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/" title="SpringBoot事物传播机制">http://blog.huanlee.cn/computer-science/java/SpringBoot事物传播机制/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="nav"><div class="item left"><a href="/computer-science/java/SpringBoot%E7%BD%91%E5%85%B3%E5%AF%B9%E5%A4%96%E6%8E%A5%E5%8F%A3%E7%AD%BE%E5%90%8D/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciundwu5j20zk0m8n9e.jpg" title="SpringBoot网关对外接口签名"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>SpringBoot网关对外接口签名</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments" data-id="computer-science/java/SpringBoot事物传播机制/"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#spring-boot-transaction"><span class="toc-number">1.</span> <span class="toc-text">Spring Boot Transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">事物管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">事务提交方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E8%A7%84%E5%88%99"><span class="toc-number">1.4.</span> <span class="toc-text">事务回滚规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.</span> <span class="toc-text">事务常用配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.6.</span> <span class="toc-text">事物注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.</span> <span class="toc-text">事务传播行为</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#required"><span class="toc-number">2.1.</span> <span class="toc-text">REQUIRED</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#supports"><span class="toc-number">2.2.</span> <span class="toc-text">SUPPORTS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mandatory"><span class="toc-number">2.3.</span> <span class="toc-text">MANDATORY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not_support"><span class="toc-number">2.4.</span> <span class="toc-text">NOT_SUPPORT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#never"><span class="toc-number">2.5.</span> <span class="toc-text">NEVER</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nested"><span class="toc-number">2.6.</span> <span class="toc-text">NESTED</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#requires_new"><span class="toc-number">2.7.</span> <span class="toc-text">REQUIRES_NEW</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">事物方法之间的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">同类方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">不同类方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">结论总结</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-science/java/ParallelStream%E5%B9%B6%E8%A1%8C%E6%B5%81%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" rel="bookmark" title="ParallelStream并行流使用注意事项">ParallelStream并行流使用注意事项</a></li><li class="active"><a href="/computer-science/java/SpringBoot%E4%BA%8B%E7%89%A9%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/" rel="bookmark" title="SpringBoot事物传播机制">SpringBoot事物传播机制</a></li><li><a href="/computer-science/java/SpringBoot%E7%BD%91%E5%85%B3%E5%AF%B9%E5%A4%96%E6%8E%A5%E5%8F%A3%E7%AD%BE%E5%90%8D/" rel="bookmark" title="SpringBoot网关对外接口签名">SpringBoot网关对外接口签名</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Lee" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Lee</p><div class="description" itemprop="description">见习码农</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">6</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dpdEh1YW5MZWU=" title="https:&#x2F;&#x2F;github.com&#x2F;GitHuanLee"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9qaW5nLXNoZW4teWktY2hhbmctNQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;jing-shen-yi-chang-5"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTExNjA4Mzc1Ng==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;116083756"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmxpaHVhbjM1MTBAcXEuY29t" title="mailto:lihuan3510@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Lee @ Lee</span></div><div><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">32k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">30 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"http://blog.huanlee.cn/computer-science/java/SpringBoot%E4%BA%8B%E7%89%A9%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 ${query} ，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return e===LOCAL.path}]}</script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/velocity-animate@1.5.2/velocity.min.js,npm/velocity-animate@1.5.2/velocity.ui.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.1.6"></script></body></html><!-- rebuild by hrmmi -->